package filter

import (
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/kubernetes"
)

type FilterEngine struct {
	config *FilterConfig
}

func NewFilterEngine(config *FilterConfig) *FilterEngine {
	return &FilterEngine{config: config}
}

func (f *FilterEngine) FilterVulnerabilities(vulns []vuln.Vulnerability) ([]vuln.Vulnerability, []vuln.Vulnerability) {
	audited := make([]vuln.Vulnerability, 0)
	found := make([]vuln.Vulnerability, 0)

	for _, vuln := range vulns {
		_, notFiltered := matchesAnyFilter(vuln, f.config.Ignore)
		filtered, notFiltered := matchesAnyFilter(notFiltered, f.config.Audit)
		if len(filtered.Containers) > 0 {
			audited = append(audited, filtered)
		}

		if len(notFiltered.Containers) > 0 {
			found = append(found, notFiltered)
		}
	}

	return found, audited
}

func matchesAnyFilter(v vuln.Vulnerability, filters []VulnerabilityFilter) (vuln.Vulnerability, vuln.Vulnerability) {
	for _, filter := range filters {
		match, filtered, notFiltered := matches(v, filter)
		if match {
			return filtered, notFiltered
		}
	}

	return vuln.Vulnerability{}, v
}

func matches(v vuln.Vulnerability, filter VulnerabilityFilter) (bool, vuln.Vulnerability, vuln.Vulnerability) {
	appliedContainers := make([]kubernetes.ContainerInfo, 0)
	notAppliedContainers := make([]kubernetes.ContainerInfo, 0)

	if v.ID != filter.Vulnerability && v.Package != filter.Package {
		notAppliedContainers = v.Containers
		return false, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	} else if len(filter.Context) == 0 {
		appliedContainers = v.Containers
		return true, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	for _, container := range v.Containers {
		name := container.OwnerName
		if container.OwnerKind == "Pod" {
			name = container.PodName
		}

		applied := false
		for _, ctx := range filter.Context {
			if matchesContainer(v.ImageID, ctx.Image) &&
				matchesContainer(container.OwnerKind, ctx.Kind) &&
				matchesContainer(name, ctx.Name) &&
				matchesContainer(container.Namespace, ctx.Namespace) {
				appliedContainers = append(appliedContainers, container)
				applied = true
				break
			}
		}
		if !applied {
			notAppliedContainers = append(notAppliedContainers, container)
		}
	}

	return len(appliedContainers) != 0, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
}

func matchesContainer(value, pattern string) bool {
	if pattern == "" {
		return true
	}

	return vuln.IsMatch(value, pattern)
}

func fromVulnerability(v vuln.Vulnerability, containers []kubernetes.ContainerInfo) vuln.Vulnerability {
	return vuln.Vulnerability{
		ID:         v.ID,
		Namespace:  v.Namespace,
		Severity:   v.Severity,
		Type:       v.Type,
		Package:    v.Package,
		Installed:  v.Installed,
		FixedIn:    v.FixedIn,
		FixState:   v.FixState,
		URLs:       v.URLs,
		ImageID:    v.ImageID,
		Containers: containers,
	}
}
