package filter

import (
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/kubernetes"
)

type FilterMaps struct {
	Package       map[string][]FilterContext
	Vulnerability map[string][]FilterContext
}

type FilterEngine struct {
	Ignore FilterMaps
	Audit  FilterMaps
}

func NewFilterEngine(config *FilterConfig) *FilterEngine {
	ignoreMaps := createFilterMaps(config.Ignore)
	auditMaps := createFilterMaps(config.Audit)
	return &FilterEngine{
		Ignore: ignoreMaps,
		Audit:  auditMaps,
	}
}

func createFilterMaps(filters []VulnerabilityFilter) FilterMaps {
	filterMaps := FilterMaps{
		Package:       make(map[string][]FilterContext),
		Vulnerability: make(map[string][]FilterContext),
	}
	for _, filter := range filters {
		if filter.Package != "" {
			filterMaps.Package[filter.Package] = append(filterMaps.Package[filter.Package], filter.Context...)
		}
		if filter.Vulnerability != "" {
			filterMaps.Vulnerability[filter.Vulnerability] = append(filterMaps.Vulnerability[filter.Vulnerability], filter.Context...)
		}
	}
	return filterMaps
}

func (f *FilterEngine) FilterVulnerabilities(vulns []vuln.Vulnerability) ([]vuln.Vulnerability, []vuln.Vulnerability) {
	audited := make([]vuln.Vulnerability, 0)
	found := make([]vuln.Vulnerability, 0)

	for _, vuln := range vulns {
		_, notFiltered := contextsMatch(vuln, f.Ignore)
		filtered, notFiltered := contextsMatch(notFiltered, f.Audit)
		if len(filtered.Containers) > 0 {
			audited = append(audited, filtered)
		}

		if len(notFiltered.Containers) > 0 {
			found = append(found, notFiltered)
		}
	}

	return found, audited
}

func getFilterContexts(vulnerability vuln.Vulnerability, filterMaps FilterMaps) []FilterContext {
	var filterContexts []FilterContext
	if contexts, ok := filterMaps.Vulnerability[vulnerability.ID]; ok {
		filterContexts = append(filterContexts, contexts...)
	}
	if contexts, ok := filterMaps.Package[vulnerability.Package]; ok {
		filterContexts = append(filterContexts, contexts...)
	}
	return filterContexts
}

func contextsMatch(v vuln.Vulnerability, filterMaps FilterMaps) (vuln.Vulnerability, vuln.Vulnerability) {
	appliedContainers := make([]kubernetes.ContainerInfo, 0)
	notAppliedContainers := make([]kubernetes.ContainerInfo, 0)

	filterContexts := getFilterContexts(v, filterMaps)

	for _, container := range v.Containers {
		name := container.OwnerName
		if container.OwnerKind == "Pod" {
			name = container.PodName
		}

		applied := false
		for _, ctx := range filterContexts {
			if matchesContainer(v.ImageID, ctx.Image) &&
				matchesContainer(container.OwnerKind, ctx.Kind) &&
				matchesContainer(name, ctx.Name) &&
				matchesContainer(container.Namespace, ctx.Namespace) {
				appliedContainers = append(appliedContainers, container)
				applied = true
				break
			}
		}
		if !applied {
			notAppliedContainers = append(notAppliedContainers, container)
		}
	}

	return fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
}

func matchesContainer(value, pattern string) bool {
	if pattern == "" {
		return true
	}

	return vuln.IsMatch(value, pattern)
}

func fromVulnerability(v vuln.Vulnerability, containers []kubernetes.ContainerInfo) vuln.Vulnerability {
	return vuln.Vulnerability{
		ID:         v.ID,
		Namespace:  v.Namespace,
		Severity:   v.Severity,
		Type:       v.Type,
		Package:    v.Package,
		Installed:  v.Installed,
		FixedIn:    v.FixedIn,
		FixState:   v.FixState,
		URLs:       v.URLs,
		ImageID:    v.ImageID,
		Containers: containers,
	}
}
