package filter

import (
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
)

type FilterEngine struct {
	config *FilterConfig
}

func NewFilterEngine(config *FilterConfig) *FilterEngine {
	return &FilterEngine{config: config}
}

func (f *FilterEngine) FilterVulnerabilities(vulns []vuln.Vulnerability) ([]vuln.Vulnerability, []vuln.Vulnerability) {
	audited := make([]vuln.Vulnerability, 0)
	found := make([]vuln.Vulnerability, 0)

	for _, vuln := range vulns {
		matches := matchesAnyFilter(vuln, f.config.Ignore)
		if matches {
			continue
		}

		matches = matchesAnyFilter(vuln, f.config.Audit)
		if matches {
			audited = append(audited, vuln)
			continue
		}

		found = append(found, vuln)
	}

	return found, audited
}

func matchesAnyFilter(vuln vuln.Vulnerability, filters []VulnerabilityFilter) bool {
	for _, filter := range filters {
		match := matches(vuln, filter)
		if match {
			return true
		}
	}

	return false
}

func matches(vuln vuln.Vulnerability, filter VulnerabilityFilter) bool {
	canRuleApply := true
	if len(filter.Context) > 0 {
		canRuleApply = false
		for _, ctx := range filter.Context {
			for _, container := range vuln.Containers {
				name := container.OwnerName
				if container.OwnerKind == "Pod" {
					name = container.PodName
				}

				if matchesContainer(vuln.ImageID, ctx.Image) &&
					matchesContainer(container.OwnerKind, ctx.Kind) &&
					matchesContainer(name, ctx.Name) &&
					matchesContainer(container.Namespace, ctx.Namespace) {
					canRuleApply = true
					break
				}
			}
		}
	}

	if !canRuleApply {
		return false
	}

	if vuln.ID == filter.Vulnerability {
		return true
	}

	if vuln.Package == filter.Package {
		return true
	}

	return false
}

func matchesContainer(value, pattern string) bool {
	if pattern == "" {
		return true
	}

	return vuln.IsMatch(value, pattern)
}
