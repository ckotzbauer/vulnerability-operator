package policyreport

import (
	"context"
	"fmt"
	"time"

	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/kubernetes"
	"github.com/sirupsen/logrus"

	libk8s "github.com/ckotzbauer/libk8soci/pkg/kubernetes"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/util/retry"

	policyreport "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/api/wgpolicyk8s.io/v1alpha2"
	wgclient "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/generated/v1alpha2/clientset/versioned"
)

type podVulnerability struct {
	container     kubernetes.ContainerInfo
	vulnerability vuln.Vulnerability
}

type PolicyReportTarget struct {
	foundVulns   map[string][]podVulnerability
	auditedVulns map[string][]podVulnerability
}

func NewPolicyReportTarget() *PolicyReportTarget {
	return &PolicyReportTarget{foundVulns: map[string][]podVulnerability{}, auditedVulns: map[string][]podVulnerability{}}
}

func (t *PolicyReportTarget) Initialize() {
}

func (t *PolicyReportTarget) ValidateConfig() error {
	return nil
}

func (t *PolicyReportTarget) ProcessVulns(result vuln.ScanResult) error {
	for _, v := range result.FoundVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := t.foundVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			t.foundVulns[id] = podVulns
		}
	}

	for _, v := range result.AuditedVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := t.auditedVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			t.auditedVulns[id] = podVulns
		}
	}

	return nil
}

func (t *PolicyReportTarget) Finalize() error {
	cfg, err := libk8s.DefaultConfig()
	if err != nil {
		logrus.WithError(err).Error("RestConfig detection failed")
		return err
	}

	ctl, err := wgclient.NewForConfig(cfg)
	if err != nil {
		logrus.WithError(err).Error("Client creation failed")
		return err
	}

	for _, podVulns := range t.foundVulns {
		finalizePodVulns(podVulns, ctl, false)
	}

	for _, podVulns := range t.auditedVulns {
		finalizePodVulns(podVulns, ctl, true)
	}

	return nil
}

func finalizePodVulns(podVulns []podVulnerability, ctl *wgclient.Clientset, audited bool) {
	v := podVulns[0]

	namespacedReport := ctl.Wgpolicyk8sV1alpha2().PolicyReports(v.container.Namespace)
	report := generatePolicyReport(v.container, podVulns, audited)

	_, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		logrus.Debugf("Create PolicyReport %s/%s", v.container.Namespace, report.Name)
		_, err = namespacedReport.Create(context.Background(), report, metav1.CreateOptions{})
		if err != nil {
			logrus.WithError(err).Error("PolicyReport could not be created")
		}
	} else if err != nil {
		logrus.WithError(err).Error("PolicyReport could not be fetched")
	} else {
		retryErr := retry.RetryOnConflict(retry.DefaultRetry, func() error {
			getObj, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
			if errors.IsNotFound(err) {
				// This doesnt ever happen even if it is already deleted or not found
				logrus.Warnf("PolicyReport %s not found for update", report.Name)
				return nil
			}

			if err != nil {
				return err
			}

			logrus.Debugf("Update PolicyReport %s/%s", v.container.Namespace, report.Name)
			report.SetResourceVersion(getObj.GetResourceVersion())
			_, updateErr := namespacedReport.Update(context.Background(), report, metav1.UpdateOptions{})
			return updateErr
		})

		if retryErr != nil {
			logrus.WithError(retryErr).Error("PolicyReport could not be updated")
		}
	}
}

func generatePolicyReport(container kubernetes.ContainerInfo, vulnerabilities []podVulnerability, audited bool) *policyreport.PolicyReport {
	suffix := ""
	if audited {
		suffix = "-audited"
	}

	report := policyreport.PolicyReport{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("vuln-%s%s", container.PodName, suffix),
			Namespace: container.Namespace,
			Labels: map[string]string{
				"kubernetes.io/created-by": "vulnerability-operator",
			},
			OwnerReferences: []metav1.OwnerReference{
				{APIVersion: "v1", Kind: "Pod", Name: container.PodName, UID: container.PodUID},
			},
		},
		Scope:   &corev1.ObjectReference{Kind: "Pod", Namespace: container.Namespace, Name: container.PodName, UID: container.PodUID},
		Results: []*policyreport.PolicyReportResult{},
	}

	t := time.Now()
	tUnix := t.Unix()
	tUnixNano := int32(t.UnixNano())

	for _, v := range vulnerabilities {
		result := policyreport.PolicyReportResult{
			Timestamp:   metav1.Timestamp{Nanos: tUnixNano, Seconds: tUnix},
			Policy:      v.vulnerability.ID,
			Description: fmt.Sprintf("%s: %s", v.vulnerability.Package, v.vulnerability.ID),
			Source:      "vulnerability-operator",
			Category:    v.vulnerability.Package,
			Scored:      false,
			Subjects: []*corev1.ObjectReference{
				{
					Kind:      "Pod",
					Namespace: container.Namespace,
					Name:      container.PodName,
					UID:       container.PodUID,
				},
			},
			Severity: mapSeverity(v.vulnerability.Severity),
			Properties: map[string]string{
				"InstalledVersion": v.vulnerability.Installed,
				"FixedVersion":     firstOrEmpty(v.vulnerability.FixedIn),
				"URL":              firstOrEmpty(v.vulnerability.URLs),
			},
			Result: mapResult(v.vulnerability.Severity),
		}

		report.Results = append(report.Results, &result)
	}

	report.Summary = toSummaryPolicy(report.Results)
	return &report
}

func mapSeverity(s string) policyreport.PolicyResultSeverity {
	if s == "Low" {
		return "low"
	} else if s == "Medium" {
		return "medium"
	} else if s == "High" || s == "Critical" {
		return "high"
	}

	return ""
}

func mapResult(s string) policyreport.PolicyResult {
	if s == "Low" {
		return "warn"
	} else if s == "Medium" || s == "High" || s == "Critical" {
		return "fail"
	}

	return "pass"
}

func toSummaryPolicy(results []*policyreport.PolicyReportResult) policyreport.PolicyReportSummary {
	var rs policyreport.PolicyReportSummary
	for _, v := range results {
		switch v.Result {
		case "error":
			rs.Error++
		case "fail":
			rs.Fail++
		case "warn":
			rs.Warn++
		case "pass":
			rs.Pass++
		default:
			rs.Skip++
		}
	}
	return rs
}

func firstOrEmpty(slice []string) string {
	if len(slice) > 0 {
		return slice[0]
	}

	return ""
}
