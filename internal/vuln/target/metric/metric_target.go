package metric

import (
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

var (
	vulnMetric = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "vuln_operator_cves",
		Help: "Number of CVE occurrences.",
	}, []string{"cve", "severity", "package", "version", "type", "fix_state", "image_id", "k8s_namespace", "k8s_name", "k8s_kind", "container_name"})

	auditedMetric = promauto.NewGaugeVec(prometheus.GaugeOpts{
		Name: "vuln_operator_cves_audit",
		Help: "Number of CVE occurrences already audited.",
	}, []string{"cve", "severity", "package", "version", "type", "fix_state", "image_id", "k8s_namespace", "k8s_name", "k8s_kind", "container_name"})
)

type MetricTarget struct {
}

func NewMetricTarget() *MetricTarget {
	return &MetricTarget{}
}

func (t *MetricTarget) Initialize() {
	vulnMetric.Reset()
	auditedMetric.Reset()
}

func (t *MetricTarget) ValidateConfig() error {
	return nil
}

func (t *MetricTarget) ProcessVulns(result vuln.ScanResult) error {
	for _, v := range result.FoundVulnerabilities {
		if v.FixState != "wont-fix" {
			for _, c := range v.Containers {
				vulnMetric.WithLabelValues(
					v.ID,
					v.Severity,
					v.Package,
					v.Installed,
					v.Type,
					v.FixState,
					v.ImageID,
					c.Namespace,
					c.OwnerName,
					c.OwnerKind,
					c.ContainerName).Set(1)
			}
		}
	}

	for _, v := range result.AuditedVulnerabilities {
		if v.FixState != "wont-fix" {
			for _, c := range v.Containers {
				auditedMetric.WithLabelValues(
					v.ID,
					v.Severity,
					v.Package,
					v.Installed,
					v.Type,
					v.FixState,
					v.ImageID,
					c.Namespace,
					c.OwnerName,
					c.OwnerKind,
					c.ContainerName).Set(1)
			}
		}
	}

	return nil
}

func (t *MetricTarget) Finalize() error {
	return nil
}
