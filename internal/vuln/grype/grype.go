package grype

import (
	"fmt"
	"os"

	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	v3 "github.com/anchore/grype/grype/db/v3"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/matcher"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/syft/syft/pkg/cataloger"
	"github.com/ckotzbauer/libk8soci/pkg/oci"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/kubernetes"
	"github.com/ckotzbauer/vulnerability-operator/internal/vuln/source"
	"github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
)

type Grype struct {
	provider         vulnerability.Provider
	metadataProvider vulnerability.MetadataProvider
	kubeClient       *kubernetes.KubeClient
	config           grypeConfig
	relatedEntries   map[string]string
	onlyFixed        bool
	minSeverity      string
	grypeConfigFile  string
}

type grypeConfig struct {
	Ignore []match.IgnoreRule `yaml:"ignore"`
}

func New(grypeConfigFile, minSeverity string, onlyFixed bool) (Grype, error) {
	grypeCfg := grypeConfig{}

	if grypeConfigFile != "" {
		_, err := os.Stat(grypeConfigFile)
		if err == nil {
			data, err := os.ReadFile(grypeConfigFile)
			if err != nil {
				logrus.WithError(err).Errorf("Count not load grype-config-file at %s", grypeConfigFile)
				return Grype{}, err
			}

			err = yaml.Unmarshal(data, &grypeCfg)
			if err != nil {
				logrus.WithError(err).Error("Failed to unmarshal the grype-config")
				return Grype{}, err
			}
		}

		if err != nil {
			logrus.Error(err)
			return Grype{}, err
		}
	}

	config := db.Config{
		ListingURL: "https://toolbox-data.anchore.io/grype/databases/listing.json",
		DBRootDir:  "/tmp/grype/db",
	}

	logrus.Debug("Load vulnerability database")
	provider, metadataProvider, dbStatus, err := grype.LoadVulnerabilityDB(config, true)
	if err = validateDBLoad(err, dbStatus); err != nil {
		logrus.Error(err)
		return Grype{}, err
	}

	client := kubernetes.NewClient()

	return Grype{
		provider:         provider,
		metadataProvider: metadataProvider,
		kubeClient:       client,
		config:           grypeCfg,
		relatedEntries:   map[string]string{},
	}, nil
}

func (s *Grype) ScanItem(item source.ScanItem) ([]Vulnerability, error) {
	if sbom, ok := item.(source.Sbom); ok {
		err := os.WriteFile("/tmp/sbom", []byte(sbom.Sbom), 0640)
		if err != nil {
			logrus.WithError(err).Error("SBOM could not be saved")
			return []Vulnerability{}, err
		}
	} else if img, ok := item.(source.Image); ok {
		err := oci.SaveImage("/tmp/image.tar.gz", img.Image)
		if err != nil {
			logrus.WithError(fmt.Errorf("failed to save image: %w", err)).Error()
			return []Vulnerability{}, err
		}
	}

	packages, context, err := pkg.Provide(item.ScanInput(), pkg.ProviderConfig{CatalogingOptions: cataloger.DefaultConfig()})
	item.Cleanup()

	if err != nil {
		logrus.WithError(fmt.Errorf("failed to catalog: %w", err)).Error()
		return []Vulnerability{}, err
	}

	matchers := matcher.NewDefaultMatchers(matcher.Config{})

	allMatches := grype.FindVulnerabilitiesForPackage(s.provider, context.Distro, matchers, packages)
	remainingMatches, _ := match.ApplyIgnoreRules(allMatches, s.config.Ignore)
	vulns := s.buildVulnerabilities(remainingMatches, item.ImageId())
	return s.filterVulnerabilities(vulns), nil
}

func validateDBLoad(loadErr error, status *db.Status) error {
	if loadErr != nil {
		return fmt.Errorf("failed to load vulnerability db: %w", loadErr)
	}
	if status == nil {
		return fmt.Errorf("unable to determine DB status")
	}
	if status.Err != nil {
		return fmt.Errorf("db could not be loaded: %w", status.Err)
	}
	return nil
}

func (s *Grype) buildVulnerabilities(matches match.Matches, imageID string) []Vulnerability {
	vulnerabilities := make([]Vulnerability, 0)

	for m := range matches.Enumerate() {
		metadata, err := s.metadataProvider.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
		if err != nil {
			continue
		}

		fixedIn := []string{}
		if m.Vulnerability.Fix.State == v3.FixedState {
			fixedIn = m.Vulnerability.Fix.Versions
		}

		if m.Vulnerability.RelatedVulnerabilities != nil {
			for _, ref := range m.Vulnerability.RelatedVulnerabilities {
				s.relatedEntries[fmt.Sprintf("%s:%s", m.Vulnerability.Namespace, m.Vulnerability.ID)] =
					fmt.Sprintf("%s:%s", ref.Namespace, ref.ID)
			}
		}

		infos, _ := s.kubeClient.GetContainersWithImage(imageID)
		vulnerabilities = append(vulnerabilities, Vulnerability{
			ID:         m.Vulnerability.ID,
			Namespace:  m.Vulnerability.Namespace,
			Severity:   metadata.Severity,
			Type:       string(m.Package.Type),
			Package:    m.Package.Name,
			Installed:  m.Package.Version,
			FixedIn:    fixedIn,
			FixState:   string(m.Vulnerability.Fix.State),
			URLs:       metadata.URLs,
			ImageID:    imageID,
			Containers: infos,
		})
	}

	return vulnerabilities
}

func (s *Grype) filterVulnerabilities(allVulns []Vulnerability) []Vulnerability {
	minSeverity := vulnerability.ParseSeverity(s.minSeverity)

	vulns := make([]Vulnerability, 0)

	for _, v := range allVulns {
		if s.hasRelated(v, allVulns) {
			continue
		}

		sev := vulnerability.ParseSeverity(v.Severity)
		if sev >= minSeverity && v.Installed != "" {
			if s.onlyFixed {
				if v.FixState == string(v3.FixedState) {
					vulns = append(vulns, v)
				}
			} else {
				vulns = append(vulns, v)
			}
		}
	}

	return vulns
}

func (s *Grype) hasRelated(v Vulnerability, all []Vulnerability) bool {
	for original, related := range s.relatedEntries {
		if original == fmt.Sprintf("%s:%s", v.Namespace, v.ID) {
			for _, a := range all {
				if fmt.Sprintf("%s:%s", a.Namespace, a.ID) == related {
					return true
				}
			}

			return false
		}
	}

	return false
}
